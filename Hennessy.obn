MODULE Hennessy;
(*  
	This is a suite of benchmarks that are relatively short, both in program
	size and execution time.  It requires no input, and prints the execution
	time for each program, using the system-dependent routine Getclock,
	below, to find out the current CPU time.  It does a rudimentary check to
	make sure each program gets the right output.  These programs were
	gathered by John Hennessy and modified by Peter Nye.
	Oberon: J. Templ  26.2.90

	Modifications

	98.05.01  --  (bsmith@cs.oberlin.edu)
	1. No longer imports SYSTEM.
	2. Performs Each test 100 times instead of the previous 10 (CONST repetitions)
	3. Properly handles implementations with different Input.TimeUnit values.
	4. Defined the procedure WriteReal, which may need to be modified under
	   versions other than System-3 (Texts.WriteRealFix has a different interface
	   in V4 than in System-3).

	98.05.18  --  (bsmith@cs.oberlin.edu)
	1. Parameters iy and yfl of Uniform11 are now VAR parameters. Without this
	   change the procedure is a NoOp.
	2. Now performs 4 sets of each test. (number of repetitions per set determined
	   by the constant repetitions.) Prints figures in five columns, four results, 
	   last column is the mean.

	2000.07.12/kjg 
	Ported to Component Pascal 

	17 Aug 2001 - Hans Klaver (hklaver@dds.nl)
	Ported to BlackBox Component Framework.
	This version has no nested procedures; all datatypes are globally declared and initialized.
	
	6 Oct 2019 - Hans Klaver (hklaver@dds.nl)
	Ported to Oberon-07
*)

	IMPORT
		Input, Out (*, Convert := extConvert *);

	CONST
		repetitions = 10;

		(* Perm *)
		permMax = 10;

		(* Towers *)
		maxCells = 15;
		stackMax = 3;

		(* Intmm, Mm *)
		rowSize = 40;

		(* Puzzle *)
		size = 511;
		classMax = 3;
		typeMax = 12;
		d = 8;

		(* Bubble, Quick *)
		sortElements = 5000;
		srtElements = 500;
		
		(* FFT *)
		fftSize = 256;
		fftSize2 = 129;

	TYPE
		(* Towers *)
		Element = RECORD
			discsize: INTEGER;
			next: INTEGER
		END;

		(* Intmm, Mm *) 
		IntMatrix = ARRAY rowSize + 1, rowSize + 1 OF INTEGER;
    RealMatrix = ARRAY rowSize + 1,rowSize + 1 OF REAL;
    
		(* Tree *)
		Node = POINTER TO RECORD
			val: INTEGER;
			left, right: Node
		END;
		
		(* FFT *)
		Complex = RECORD
			rp, ip: REAL
		END;
    CmplArray = ARRAY fftSize + 1 OF Complex;
    Cmpl2Array = ARRAY fftSize2 + 1 OF Complex;

	VAR
		(* global *)
		seed: INTEGER;
(*
		ix: INTEGER;
		jx: INTEGER;
*)
		t0: INTEGER;
		t1: INTEGER;
		t2: INTEGER;
		t3: INTEGER;

		(* Perm *) 
		permArray: ARRAY permMax + 1 OF INTEGER;
		pctr: INTEGER;

		(* Towers *)
		stack: ARRAY stackMax + 1 OF INTEGER;
		cellspace: ARRAY maxCells + 1 OF Element;
		freelist: INTEGER;
		movesDone: INTEGER;

		(* Intmm, Mm *)
		ima, imb, imr: IntMatrix;
		rma, rmb, rmr: RealMatrix;

		(* Puzzle *)
		pieceCount: ARRAY classMax + 1 OF INTEGER;
		class, pieceMax: ARRAY typeMax + 1 OF INTEGER;
		puzzl: ARRAY size + 1 OF BOOLEAN;
		p: ARRAY typeMax + 1, size + 1 OF BOOLEAN;
		n: INTEGER;
		kount: INTEGER;

		(* Bubble, Quick *)
		sortList: ARRAY sortElements + 1 OF INTEGER;
		biggest: INTEGER; 
		littlest: INTEGER;
		top: INTEGER;

		(* Tree *)
		tree: Node;
		
		(* FFT *)
		z, w: CmplArray;
    e: Cmpl2Array;
		zr, zi: REAL;


	(* global procedures *)

	PROCEDURE Str (s: ARRAY OF CHAR);
	BEGIN
		Out.String(s)
	END Str;

	PROCEDURE Line (s: ARRAY OF CHAR);
	BEGIN
		Out.String(s); Out.Ln
	END Line;

	PROCEDURE InitRand ();
	BEGIN seed := 74755
	END InitRand;

	PROCEDURE Rand (): INTEGER;
	BEGIN
		seed := (seed * 1309 + 13849) MOD 65535;
		RETURN (seed)
	END Rand;


	(* Perm -- Permutation program, heavily recursive, written by Denny Brown. *)

	PROCEDURE Swap (VAR a, b: INTEGER);
		VAR t: INTEGER;
	BEGIN 
		t := a;  a := b;  b := t;
	END Swap;

	PROCEDURE Initialize ();
		VAR i: INTEGER;
	BEGIN i := 1;
		WHILE i <= 7 DO
			permArray[i] := i - 1;
			INC(i)
		END
	END Initialize;

	PROCEDURE Permute (n: INTEGER);
		VAR k: INTEGER;
	BEGIN
		INC(pctr);
		IF n # 1 THEN
			Permute(n-1);
			k := n-1;
			WHILE k >= 1 DO
				Swap(permArray[n], permArray[k]);
				Permute(n - 1);
				Swap(permArray[n], permArray[k]);
				DEC(k)
			END
		END
	END Permute;

	PROCEDURE Perm;
		VAR i: INTEGER;
	BEGIN
		pctr := 0;  i := 1;
		WHILE i <= 500 DO  (* originally i <= 5 *)
			Initialize();
			Permute(7);
			INC(i)
		END;
		IF pctr # 4330000 THEN Line(" Error in Perm.") END
	END Perm;


  (* Towers -- Solves the Towers of Hanoi *)

  PROCEDURE MakeNull (s: INTEGER);
  BEGIN 
    stack[s] := 0
  END MakeNull;

  PROCEDURE GetElement (): INTEGER;
    VAR temp: INTEGER;
  BEGIN
    IF freelist > 0 THEN
      temp := freelist;
      freelist := cellspace[freelist].next;
    ELSE
      temp := 0;
      Line("out of space   ")
    END;
    RETURN temp
  END GetElement;
  
  PROCEDURE Push(i, s: INTEGER);
        VAR localel: INTEGER; errorfound: BOOLEAN;
  BEGIN
    errorfound := FALSE;
    IF ( stack[s] > 0 ) THEN
      IF ( cellspace[stack[s]].discsize <= i ) THEN
        errorfound := TRUE;
        Line("disc size error")
      END 
    END ;
    IF ( ~ errorfound ) THEN
      localel := GetElement();
      cellspace[localel].next := stack[s];
      stack[s] := localel;
      cellspace[localel].discsize := i
    END
  END Push;
  
  PROCEDURE Init (s, n: INTEGER);
    VAR discctr: INTEGER;
  BEGIN
    MakeNull(s); discctr := n;
    WHILE discctr >= 1 DO
      Push(discctr, s);
      DEC(discctr)
    END
  END Init;

  PROCEDURE Pop (s: INTEGER; VAR result: INTEGER);
    VAR temp, temp1: INTEGER;
  BEGIN
    IF ( stack[s] > 0 ) THEN
      temp1 := cellspace[stack[s]].discsize;
      temp := cellspace[stack[s]].next;
      cellspace[stack[s]].next := freelist;
      freelist := stack[s];
      stack[s] := temp;
      result := temp1;
    ELSE
      result := 0;
      Line("nothing to pop ")
    END
  END Pop;

	PROCEDURE Move (s1, s2: INTEGER);
		VAR result: INTEGER;
	BEGIN
		Pop(s1, result);
		Push(result, s2);
		INC(movesDone)
	END Move;

	PROCEDURE Tower(i, j , k: INTEGER);
		VAR other: INTEGER;
	BEGIN
		IF k = 1 THEN
			Move(i, j)
		ELSE
			other := 6 - i - j;
			Tower(i, other, k - 1);
			Move(i, j);
			Tower(other, j, k - 1)
		END
	END Tower;

	PROCEDURE Towers;
		VAR i: INTEGER;
	BEGIN 
		FOR i := 1 TO maxCells DO cellspace[i].next := i - 1 END;
		freelist := maxCells;
		Init(1, 14);
		MakeNull(2);
		MakeNull(3);
		movesDone := 0;
		Tower(1, 2, 14);
		IF movesDone # 16383 THEN Line(" Error in Towers.") END
	END Towers;


	(* Queens -- The eight queens problem, solved 50 times. *)
	(*
		type
			doubleboard =  2..16;
			doublenorm  = -7..7;
			boardrange  =  1..8;
			aarray      =  array [boardrange] of boolean;
			barray      =  array [doubleboard] of boolean;
			carray      =  array [doublenorm] of boolean;
			xarray      =  array [boardrange] of boardrange;
	*)

	(* dependent upon reference semantics of ARRAY * OF T ! *)

	PROCEDURE Try (i: INTEGER; VAR q: BOOLEAN; VAR a, b, c: ARRAY OF BOOLEAN; VAR x: ARRAY OF INTEGER);
		VAR j: INTEGER;
	BEGIN
		j := 0;
		q := FALSE;
		WHILE (~q) & (j # 8) DO
			j := j + 1;
			q := FALSE;
			IF b[j] & a[i + j] & c[i - j + 7] THEN
				x[i] := j;
				b[j] := FALSE;
				a[i + j] := FALSE;
				c[i - j + 7] := FALSE;
				IF i < 8 THEN
					Try(i + 1, q, a, b, c, x);
					IF ~q THEN
						b[j] := TRUE;
						a[i + j] := TRUE;
						c[i - j + 7] := TRUE
					END
				ELSE 
					q := TRUE
				END
			END
		END
	END Try;

	PROCEDURE Doit ();
		VAR i: INTEGER; q: BOOLEAN;
			a: ARRAY 9 OF BOOLEAN;
			b: ARRAY 17 OF BOOLEAN;
			c: ARRAY 15 OF BOOLEAN;
			x: ARRAY 9 OF INTEGER;
	BEGIN
		i := 0 - 7;
		WHILE i <= 16 DO
			IF (i >= 1) & (i <= 8) THEN a[i] := TRUE END ;
			IF i >= 2 THEN b[i] := TRUE END ;
			IF i <= 7 THEN c[i+7] := TRUE END ;
			i := i + 1;
		END;
		Try(1, q, b, a, c, x);
		IF ( ~q ) THEN Line(" Error in Queens.") END
	END Doit;

	PROCEDURE Queens;
		VAR i: INTEGER;
	BEGIN i := 1;
		WHILE i <= 50 DO Doit(); INC(i) END
	END Queens;


	(* Intmm -- Multiplies two integer matrices. *)

	PROCEDURE Initmatrix (VAR m: IntMatrix);
		VAR temp, i, j: INTEGER;
	BEGIN i := 1;
		WHILE i <= rowSize DO
			j := 1;
			WHILE j <= rowSize DO
				temp := Rand();
				m[i][j] := temp - (temp DIV 120)*120 - 60;
				INC(j)
			END ;
			INC(i)
		END
	END Initmatrix;

	PROCEDURE Innerproduct(VAR result: INTEGER; VAR a, b: IntMatrix; row, column: INTEGER);
  (* computes the inner product of A[row,*] and B[*,column] *)
		VAR i: INTEGER;
	BEGIN
		result := 0; i := 1;
		WHILE i <= rowSize DO 
			result := result + a[row][i] * b[i][column]; INC(i) 
		END
	END Innerproduct;

	PROCEDURE Intmm;
		VAR i, j: INTEGER;
	BEGIN
		InitRand();
		Initmatrix (ima);
		Initmatrix (imb);
		i := 1;
		WHILE i <= rowSize DO 
			j :=1;
			WHILE j <= rowSize DO Innerproduct(imr[i][j], ima, imb, i, j); INC(j) END;
			INC(i)
		END
	END Intmm;
	
	
	(* Mm -- Multiplies two floating point matrices *)

	PROCEDURE InitMatrix (VAR m: RealMatrix);
		VAR
			i, j, temp: INTEGER;
	BEGIN
		FOR i := 1 TO rowSize DO 
			FOR j := 1 TO rowSize DO
				temp := Rand();
				m[i][j] := FLT(temp - (temp DIV 120) * 120 - 60) / 3.0;
			END;
		END
	END InitMatrix;

	PROCEDURE InnerProduct (VAR result: REAL; VAR a, b: RealMatrix; row, column: INTEGER);
		(* computes the inner product of A[row,*] and B[*,column] *)
		VAR
			i: INTEGER;
	BEGIN
		result := 0.0;
		FOR i := 1 TO rowSize DO result := result + a[row][i] * b[i][column] END
	END InnerProduct;

	PROCEDURE Mm*;
		VAR
			i, j: INTEGER;
	BEGIN
		InitRand;
		InitMatrix(rma);
		InitMatrix(rmb);
		FOR i := 1 TO rowSize DO 
			FOR j := 1 TO rowSize DO 
				InnerProduct(rmr[i][j], rma, rmb, i, j); 
			END;
		END
	END Mm;


  (* Puzzle -- A compute-bound program from Forest Baskett. *)

  PROCEDURE Fit (i, j: INTEGER): BOOLEAN;
    VAR k: INTEGER; res: BOOLEAN;
  BEGIN k := 0; res := TRUE;
    WHILE (k <= pieceMax[i]) & (res = TRUE) DO
      IF ( p[i][k] ) THEN 
        IF ( puzzl[j+k] ) THEN 
          res := FALSE 
        END 
      END;
      INC(k)
    END;
    RETURN res
  END Fit;
  
  PROCEDURE Place (i, j: INTEGER): INTEGER;
    VAR k, res: INTEGER;
    	exit: BOOLEAN;
  BEGIN k := 0;
    WHILE k <= pieceMax[i] DO
      IF p[i][k] THEN puzzl[j+k] := TRUE END;
      INC(k)
    END;
    pieceCount[class[i]] := pieceCount[class[i]] - 1;
    k := j; 
(*    
    WHILE (k <= size) DO
      IF ( ~ puzzl[k] ) THEN RETURN (k) END;
      INC(k)
    END;
    RETURN (0);
*)  
	res := 0;  exit := FALSE;
    WHILE (k <= size) & (~ exit) DO
    	IF ~ puzzl[k] THEN res := k; exit := TRUE
    	ELSE INC(k)
    	END
    END; 
    RETURN res
  END Place;
  
  PROCEDURE Remove (i, j: INTEGER);
    VAR k: INTEGER;
  BEGIN k := 0;
    WHILE k <= pieceMax[i] DO
      IF ( p[i][k] ) THEN puzzl[j+k] := FALSE END;
      INC(k)
    END;
    pieceCount[class[i]] := pieceCount[class[i]] + 1
  END Remove;
  
(*  
  PROCEDURE Trial (j: INTEGER): BOOLEAN;
    VAR i, k: INTEGER;
  BEGIN i := 0;
    kount := kount + 1;
    WHILE i <= typemax DO
      IF ( piececount[kind[i]] # 0 ) THEN
        IF ( Fit (i, j) ) THEN
          k := Place (i, j);
          IF Trial(k) OR (k = 0) THEN RETURN (TRUE)
          ELSE Remove (i, j)
          END;
        END
      END;
      INC(i)
    END;
    RETURN (FALSE)
  END Trial;
*)

  PROCEDURE Trial (j: INTEGER): BOOLEAN;
    VAR i, k: INTEGER; res: BOOLEAN;
  BEGIN i := 0; res := FALSE;
    INC(kount);
    WHILE (i <= typeMax) & (res = FALSE) DO
      IF pieceCount[class[i]] # 0 THEN
        IF Fit(i, j) THEN
          k := Place(i, j);
          IF Trial(k) OR (k = 0) THEN res := TRUE
          ELSE Remove(i, j)
          END
        END
      END;
      INC(i)
    END;
    RETURN res
  END Trial;
  
	PROCEDURE Puzzle;
	  VAR i, j, k, m: INTEGER;
	BEGIN
	  m := 0; WHILE m <= size DO puzzl[m] := TRUE; INC(m) END ;
	  i := 1;
	  WHILE i <= 5 DO j := 1;
		 WHILE j <= 5 DO k := 1;
			WHILE k <= 5 DO
			  puzzl[i+d*(j+d*k)] := FALSE; INC(k)
			END;
			INC(j)
		 END;
		 INC(i)
	  END;
  
	  i := 0; 
	  WHILE i <= typeMax DO m := 0;
		 WHILE m<= size DO
			p[i][m] := FALSE; INC(m)
		 END;
		 INC(i)
	  END;
  
	  i := 0;
	  WHILE i <= 3 DO j := 0;
		 WHILE j <= 1 DO k := 0;
			WHILE k <= 0 DO
			  p[0][i+d*(j+d*k)] := TRUE; INC(k)
			END;
			INC(j)
		 END;
		 INC(i)
	  END;
	  class[0] := 0;
	  pieceMax[0] := 3+d*1+d*d*0;
  
	  i := 0;
	  WHILE i <= 1 DO j := 0;
		 WHILE j <= 0 DO k := 0;
			WHILE k <= 3 DO
			  p[1][i+d*(j+d*k)] := TRUE; INC(k)
			END;
			INC(j)
		 END;
		 INC(i)
	  END;
	  class[1] := 0;
	  pieceMax[1] := 1+d*0+d*d*3;
  
	  i := 0;
	  WHILE i <= 0 DO j := 0;
		 WHILE j <= 3 DO k := 0;
			WHILE k <= 1 DO
			  p[2][i+d*(j+d*k)] := TRUE; INC(k)
			END;
			INC(j)
		 END;
		 INC(i)
	  END;
	  class[2] := 0;
	  pieceMax[2] := 0+d*3+d*d*1;
  
	  i := 0;
	  WHILE i <= 1 DO j := 0;
		 WHILE j <= 3 DO k := 0;
			WHILE k <= 0 DO
			  p[3][i+d*(j+d*k)] := TRUE; INC(k)
			END;
			INC(j)
		 END;
		 INC(i)
	  END;
	  class[3] := 0;
	  pieceMax[3] := 1+d*3+d*d*0;

	  i := 0;
	  WHILE i <= 3 DO j := 0;
		 WHILE j <= 0 DO k := 0;
			WHILE k <= 1 DO
			  p[4][i+d*(j+d*k)] := TRUE; INC(k)
			END;
			INC(j)
		 END;
		 INC(i)
	  END;
	  class[4] := 0;
	  pieceMax[4] := 3+d*0+d*d*1;
  
	  i := 0;
	  WHILE i <= 0 DO j := 0;
		 WHILE j <= 1 DO k := 0;
			WHILE k <= 3 DO
			  p[5][i+d*(j+d*k)] := TRUE; INC(k)
			END;
			INC(j)
		 END;
		 INC(i)
	  END;
	  class[5] := 0;
	  pieceMax[5] := 0+d*1+d*d*3;
  
	  i := 0;
	  WHILE i <= 2 DO j := 0;
		 WHILE j <= 0 DO k := 0;
			WHILE k <= 0 DO
			  p[6][i+d*(j+d*k)] := TRUE; INC(k)
			END;
			INC(j)
		 END;
		 INC(i)
	  END;
	  class[6] := 1;
	  pieceMax[6] := 2+d*0+d*d*0;
  
	  i := 0;
	  WHILE i <= 0 DO j := 0;
		 WHILE j <= 2 DO k := 0;
			WHILE k <= 0 DO
			  p[7][i+d*(j+d*k)] := TRUE; INC(k)
			END;
			INC(j)
		 END;
		 INC(i)
	  END;
	  class[7] := 1;
	  pieceMax[7] := 0+d*2+d*d*0;
  
	  i := 0;
	  WHILE i <= 0 DO j := 0;
		 WHILE j <= 0 DO k := 0;
			WHILE k <= 2 DO
			  p[8][i+d*(j+d*k)] := TRUE; INC(k)
			END;
			INC(j)
		 END;
		 INC(i)
	  END;
	  class[8] := 1;
		 pieceMax[8] := 0+d*0+d*d*2;
  
	  i := 0;
	  WHILE i <= 1 DO j := 0;
		 WHILE j <= 1 DO k := 0;
			WHILE k <= 0 DO
			  p[9][i+d*(j+d*k)] := TRUE; INC(k)
			END;
			INC(j)
		 END;
		 INC(i)
	  END;
	  class[9] := 2;
	  pieceMax[9] := 1+d*1+d*d*0;
  
	  i := 0;
	  WHILE i <= 1 DO j := 0;
		 WHILE j <= 0 DO k := 0;
			WHILE k <= 1 DO
			  p[10][i+d*(j+d*k)] := TRUE; INC(k)
			END;
			INC(j)
		 END;
		 INC(i)
	  END;
	  class[10] := 2;
	  pieceMax[10] := 1+d*0+d*d*1;
  
	  i := 0;
	  WHILE i <= 0 DO j := 0;
		 WHILE j <= 1 DO k := 0;
			WHILE k <= 1 DO
			  p[11][i+d*(j+d*k)] := TRUE; INC(k)
			END;
			INC(j)
		 END;
		 INC(i)
	  END;
	  class[11] := 2;
	  pieceMax[11] := 0+d*1+d*d*1;
  
	  i := 0;
	  WHILE i <= 1 DO j := 0;
		 WHILE j <= 1 DO k := 0;
			WHILE k <= 1 DO
			  p[12][i+d*(j+d*k)] := TRUE; INC(k)
			END;
			INC(j)
		 END;
		 INC(i)
	  END;
	  class[12] := 3;
	  pieceMax[12] := 1 + d*1 + d*d*1;
  
	  pieceCount[0] := 13;
	  pieceCount[1] := 3;
	  pieceCount[2] := 1;
	  pieceCount[3] := 1;
	  m := 1 + d*(1 + d*1);
	  kount := 0;
	  IF Fit(0, m) THEN n := Place(0, m)
	  ELSE Line("Error1 in Puzzle")
	  END;
	  IF ~ Trial(n) THEN Line("Error2 in Puzzle.")
	  ELSIF kount # 2005 THEN Line("Error3 in Puzzle.")
	  END
	END Puzzle;


  (* Quick -- Sorts an array using quicksort *)

  PROCEDURE InitArr();
    VAR i, temp: INTEGER;
  BEGIN
    InitRand();
    biggest := 0; littlest := 0;
    FOR i := 1 TO sortElements DO
      temp := Rand();
      sortList[i] := temp - (temp DIV 100000)*100000 - 50000;
      IF sortList[i] > biggest THEN biggest := sortList[i]
      ELSIF sortList[i] < littlest THEN littlest := sortList[i]
      END
    END
  END InitArr;

  PROCEDURE Quicksort(VAR a: ARRAY OF INTEGER; l, r: INTEGER);
  (* quicksort the array A from start to finish *)
    VAR i, j, x, w: INTEGER;
  BEGIN
    i := l; j := r;
    x := a[(l + r) DIV 2];
    REPEAT
      WHILE a[i] < x DO i := i+1 END;
      WHILE x < a[j] DO j := j-1 END;
      IF i <= j THEN
        w := a[i];
        a[i] := a[j];
        a[j] := w;
        i := i+1;  j := j-1
      END ;
    UNTIL i > j;
    IF l < j THEN Quicksort(a, l, j) END;
    IF i < r THEN Quicksort(a, i, r) END
  END Quicksort;

	PROCEDURE Quick;
	BEGIN
		InitArr();
		Quicksort(sortList, 1, sortElements);
		IF (sortList[1] # littlest) OR (sortList[sortElements] # biggest) THEN 
			Line(" Error in Quick.") 
		END
	END Quick;


  (* Bubble -- Sorts an array using bubblesort *)

  PROCEDURE bInitArr;
    VAR i, temp: INTEGER;
  BEGIN
    InitRand();
    biggest := 0; littlest := 0;
    FOR i := 1 TO srtElements DO
      temp := Rand();
      sortList[i] := temp - (temp DIV 100000)*100000 - 50000;
      IF sortList[i] > biggest THEN biggest := sortList[i]
      ELSIF sortList[i] < littlest THEN littlest := sortList[i]
      END
    END
  END bInitArr;

	PROCEDURE Bubble;
		VAR i, j: INTEGER;
	BEGIN
		bInitArr();
		top := srtElements;
		WHILE top > 1 DO
			i := 1;
			WHILE i < top DO
				IF sortList[i] > sortList[i+1] THEN
					j := sortList[i];
					sortList[i] := sortList[i+1];
					sortList[i+1] := j
				END;
				INC(i)
			END;
			DEC(top)
		END;
		IF (sortList[1] # littlest) OR (sortList[srtElements] # biggest) THEN 
			Line("Error3 in Bubble.") 
		END
	END Bubble;


  (* Tree -- Sorts an array using treesort *)

  PROCEDURE tInitarr();
    VAR i, temp: INTEGER;
  BEGIN
    InitRand();
    biggest := 0; littlest := 0;
    FOR i := 1 TO sortElements DO
      temp := Rand();
      sortList[i] := temp - (temp DIV 100000)*100000 - 50000;
      IF sortList[i] > biggest THEN biggest := sortList[i]
      ELSIF sortList[i] < littlest THEN littlest := sortList[i]
      END
    END
  END tInitarr;

  PROCEDURE CreateNodeObject (VAR t: Node; n: INTEGER);
  BEGIN
    NEW(t);
    t.left := NIL; t.right := NIL;
    t.val := n
  END CreateNodeObject;

  PROCEDURE Insert(n: INTEGER; t: Node);
  (* insert n into tree *)
  BEGIN
    IF n > t.val THEN
      IF t.left = NIL THEN CreateNodeObject(t.left, n)
      ELSE Insert(n, t.left)
      END
    ELSIF n < t.val THEN
      IF t.right = NIL THEN CreateNodeObject(t.right, n)
      ELSE Insert(n, t.right)
      END
    END
  END Insert;

  PROCEDURE CheckTree(p: Node): BOOLEAN;
  (* check by inorder traversal *)
    VAR result: BOOLEAN;
  BEGIN
    result := TRUE;
    IF p.left # NIL THEN
      IF p.left.val <= p.val THEN result := FALSE;
      ELSE result := CheckTree(p.left) & result
      END
    END ;
    IF  p.right # NIL THEN
      IF p.right.val >= p.val THEN result := FALSE;
      ELSE result := CheckTree(p.right) & result
      END
    END;
    RETURN result
  END CheckTree;

	PROCEDURE Tree;
		VAR i: INTEGER;
	BEGIN
		tInitarr();
		NEW(tree);
		tree.left := NIL; tree.right := NIL; tree.val := sortList[1];
		FOR i := 2 TO sortElements DO
			Insert(sortList[i], tree);
		END;
		IF ~ CheckTree(tree) THEN Line(" Error in Tree.") END
	END Tree;


  (* FFT -- Fast Fourier Transform *)
  
  PROCEDURE Cos (x: REAL): REAL;
	(* computes cosine of x (x in radians) by an expansion *)
		VAR i, factor: INTEGER;
			result, power: REAL;
	BEGIN
		result := 1.0; factor := 1;  power := x; i := 2;
		WHILE i <= 10 DO
			factor := factor * i;  power := power*x;
			IF i MOD 2 = 0 THEN
				IF i MOD 4 = 0 THEN result := result + power/FLT(factor)
				ELSE result := result - power/FLT(factor)
				END
			END;
			INC(i)
		END;
		RETURN result
	END Cos;
	
	PROCEDURE Min0( arg1, arg2: INTEGER): INTEGER;
	  VAR res: INTEGER;
	BEGIN
		IF arg1 < arg2 THEN res := arg1
		ELSE res := arg2
		END;
		RETURN res
	END Min0;

	PROCEDURE Uniform11(iy: INTEGER; yfl: REAL);
	BEGIN
		iy := (4855*iy + 1731) MOD 8192;
		yfl := FLT(iy)/8192.0;
	END Uniform11;

	PROCEDURE ExpTab(n: INTEGER; VAR e: Cmpl2Array);
		VAR theta, divisor: REAL; h: ARRAY 26 OF REAL;
			i, j, k, l, m: INTEGER;
(* necessary temporary variables under Oberon for Windows: *)
			t1, t2: REAL;
	BEGIN
		theta := 3.1415926536;
		divisor := 4.0; i:=1;
		WHILE i <= 25 DO
			h[i] := 1.0/(2.0*Cos(theta/divisor));
			divisor := divisor + divisor;
			INC(i)
		END;
		m := n DIV 2 ;
		l := m DIV 2 ;
		j := 1 ;
		e[1].rp := 1.0 ;
		e[1].ip := 0.0;
		e[l+1].rp := 0.0;
		e[l+1].ip := 1.0 ;
		e[m+1].rp := -1.0 ;
		e[m+1].ip := 0.0 ;
		REPEAT
			i := l DIV 2 ;
			k := i ;
			REPEAT
				t1 := e[k+i+1].rp+e[k-i+1].rp; t2 := e[k+i+1].ip+e[k-i+1].ip;
				e[k+1].rp := h[j]*t1 ;
				e[k+1].ip := h[j]*t2 ;
				k := k+l ;
			UNTIL ( k > m );
			j := Min0( j+1, 25);
			l := i ;
		UNTIL ( l <= 1 );
	END ExpTab;

	PROCEDURE Fft( n: INTEGER; VAR z, w: CmplArray; VAR e: Cmpl2Array; sqrInv: REAL);
		VAR i, j, k, l, m, index: INTEGER; h: REAL;
(* necessary temporary variables under Oberon for Windows: *)
			t1: REAL;
	BEGIN
		m := n DIV 2 ;
		l := 1 ;
		REPEAT
			k := 0 ;
			j := l ;
			i := 1 ;
			REPEAT
				REPEAT
					w[i+k].rp := z[i].rp + z[m+i].rp;
					w[i+k].ip := z[i].ip + z[m+i].ip;
					h := e[k+1].rp * (z[i].rp-z[i+m].rp);
					t1 := z[i].ip - z[i+m].ip;
					w[i+j].rp := h - e[k+1].ip * t1;
					h := e[k+1].rp * (z[i].ip - z[i+m].ip);
					t1 := z[i].rp - z[i+m].rp;
					w[i+j].ip := h + e[k+1].ip * t1;
					INC(i);
				UNTIL ( i > j );
				k := j ;
				j := k + l ;
			UNTIL ( j > m );
			(*z := w ;*) index := 1;
			REPEAT
				z[index] := w[index];
				INC(index);
			UNTIL ( index > n );
			l := l + l ;
		UNTIL ( l > m );
		i := 1;
		WHILE i <= n DO
			z[i].rp :=  sqrInv * z[i].rp;
			z[i].ip := -sqrInv * z[i].ip;
			INC(i)
		END
	END Fft;
	
	PROCEDURE Oscar ();
		VAR i: INTEGER;
	BEGIN
		ExpTab(fftSize, e);
		seed := 5767;
		FOR i := 1 TO fftSize DO
			Uniform11( seed, zr );
			Uniform11( seed, zi );
			z[i].rp := 20.0 * zr - 10.0;
			z[i].ip := 20.0 * zi - 10.0
		END;
		FOR i := 1 TO 20 DO Fft(fftSize,z,w,e,0.0625) END
	END Oscar;


  (* Ack *)

(*
  PROCEDURE WriteFraction(t: INTEGER);
    VAR str: ARRAY 32 OF CHAR;
      done: BOOLEAN;
  BEGIN
    Convert.RealToString(FLT(t)/1000.0, str, done);
    Line(str);
  END WriteFraction;
*)  
	PROCEDURE GetMillis (): INTEGER;
	(* 
		Returns elapsed system time in ms.
		Gives less roundoff error than 
		RETURN Input.Time() DIV Input.TimeUnit * 1000
	*)
	BEGIN
		RETURN FLOOR(1000.0 / FLT(Input.TimeUnit)) * Input.Time()
	END GetMillis; 

  PROCEDURE WriteMillis(t: INTEGER);
  BEGIN
  	Out.Int(t, 5); Out.String(" ms")
  END WriteMillis;

  PROCEDURE Time(str: ARRAY OF CHAR; idx: INTEGER);
    VAR i: INTEGER;
  BEGIN
    t1 := GetMillis();
    FOR i := 1 TO repetitions DO
      CASE idx OF
      | 0: Perm;
      | 1: Towers;
      | 2: Queens;
      | 3: Intmm;
      | 4: Mm;
      | 5: Puzzle;
      | 6: Quick;
      | 7: Bubble;
      | 8: Tree;
      | 9: Oscar;
(*    |10: Ack        *)
      END;
    END;
    t2 := GetMillis();
    Out.String(str);
		WriteMillis(t2-t1);
    Out.Ln
  END Time;

	PROCEDURE Do*;
	BEGIN
    Line("Hennessy benchmarks (Oberon-07):");
		t0 := GetMillis();
		Time("Perm   ", 0);
		Time("Towers ", 1);
		Time("Queens ", 2);
		Time("Intmm  ", 3);
		Time("Mm     ", 4);
		Time("Puzzle ", 5);
		Time("Quick  ", 6);
		Time("Bubble ", 7);
		Time("Tree   ", 8);
		Time("FFT    ", 9);
(*  Time("Ack    ", 10):  *)
		t3 := GetMillis();
		Str (" Total ");
		WriteMillis(t3-t0);
		Out.Ln
	END Do;

BEGIN 
  Do
END Hennessy.
